#include <vector>
#include <algorithm>
#include <iostream>
#include <time.h>

namespace howToFillVectorWithRandomNumbers {
    // For this task we will use a STL algorithm std::generate i.e.
    // template<typename _FIter, typename _Generator>
    // void  generate(_FIter start, _FIter end, _Generator gen);
    // It will update all the elements from range start to end - 1 with values generated by gen function object.

    // Fill random Numbers in std::vector using Lambda functions
    // Let¡¯s fill a std::vector of size 10 with random numbers from 0 to 100. 
    // First of all, initialize a vector with 10 ints of value 0 i.e.
    // Initialize a vector with 10 ints of value 0
    void test()
    {
        std::cout << __FUNCTION__ << "\n";
        srand(time(0));
        std::vector<int> vecOfRandomNums(10);
        // Generate 10 random numbers by lambda func and fill it in vector
        std::generate(vecOfRandomNums.begin(), vecOfRandomNums.end(), []() {
            return rand() % 100;
        });

        for (auto elem : vecOfRandomNums)
        {
            std::cout << elem << ",";
        }
        std::cout << "\n";
    }


    // Fill Random Numbers in std::vector using a Functor

    // Define a Functor that will return a random numbe whenever called i.e.
    struct RandomGenerator {
        int maxValue;
        RandomGenerator(int max) :
            maxValue(max) {
            srand(time(0));
        }

        int operator()() {
            return rand() % maxValue;
        }
    };

    void test2()
    {
        std::cout << __FUNCTION__ << "\n";
        //Now fill vector by generating 10 random numbers using above functor i.e,
        // Initialize a vector with 10 ints of value 0
        std::vector<int> vecOfRandomNums(10);

        // Generate 10 random numbers by a Functor and fill it in vector
        std::generate(vecOfRandomNums.begin(), vecOfRandomNums.end(), RandomGenerator(500));

        for (auto elem : vecOfRandomNums)
        {
            std::cout << elem << ",";
        }
        std::cout << "\n";
    }
}

namespace inportanceOfContructorsWhileUsingUserDefinedObjects {
    //For User Defined classes if Copy Constructor and Assignment Operator are public then only one can insert it¡¯s object in std::vector.
    /*
    This is because of two reasons,
    1. All STL containers always stores the copy of inserted objects not the actual one. 
    So, whenever we insert any element or object in    container then 
    its copy constructor is called to create a copy and 
    then this copy is inserted in the container.
    2. While insertion in std::vector it might be possible that 
    storage relocation takes place internally due to insufficient space. 
    In such cases assignment operator will be called on objects 
    inside the container to copy them from one location to another.
    */
    class Sample
    {
    public:
        // Copy Constructor should not be private if we are inserting it's
        // objects in std::vector
        Sample(const Sample & obj)
        {
            std::cout << "Sample :: Copy Constructor" << std::endl;
        }

        Sample()
        {
            std::cout << "Sample :: Default Constructor" << std::endl;
        }

        Sample & operator=(const Sample & obj)
        {
            std::cout << "Sample :: Assignment Operator" << std::endl;
        }
    };
    void test()
    {
        std::cout << __FUNCTION__ << "\n";

        std::vector<Sample> vecOfSamples;
        Sample obj;
        vecOfSamples.push_back(obj);

        std::cout << "\n";
    }

    /*
    A part from this, if you are initializing the std::vector with default size by passing size as parameter i.e.
    std::vector<NewSample> vecOfNewSample(2);
    In such scenario 2 objects of NewSample will be created using default constructor. But if default constructor is not available then it will give compile error.
    */
}

namespace howToUseVectorEfficiently {
    /*
    We can use vector efficiently by taking care of following points,

    1.) Vector will be more efficient if elements are inserted or removed from the back-end only.
    2.)  Set the storage of vector initially using reserve() member function.
    3.)  Instead of adding single element in multiple calls, large set of elements is added in single call

    */
}

namespace iteratorInvalidation {
    /*
    What is Iterator Invalidation?
    Iterator invalidation in vector happens when,
    An element is inserted to vector at any location
    An element is deleted from vector.
    
    */

    //Iterator Invalidation Example on Element Deletion in vector:
    void test1()
    {
        std::vector<int> vecArr;
        for (int i = 1; i <= 10; ++i)
        {
            vecArr.push_back(i);
        }
        for (auto it = vecArr.begin(); it != vecArr.end(); it++)
            std::cout << (*it) << "  ";

        std::cout << std::endl;

        // Erase and element with value 5.
        auto it = std::find(vecArr.begin(), vecArr.end(), 5);
        if (it != vecArr.end())
            vecArr.erase(it);

        // Now iterator 'it' is invalidated because it still points to
        // old location, which has been deleted. So, if you will try to
        // do the use the same iterator then it can show undefined
        // behavior.

        for (; it != vecArr.end(); it++)   // Unpredicted Behavior
            std::cout << (*it) << "  ";          // Unpredicted Behavior

        return;
    }

    //Now, how to fix this ? 
    // Solution: After calling the erase function update the value of iterator ¡®it¡¯ i.e.
    // Erase and element with value 5.
    // auto it = std::find(vecArr.begin(), vecArr.end(), 5);
    // if (it != vecArr.end())
    //    it = vecArr.erase(it);

    // Iterator Invalidation Example on Element Insertion in vector:
    // When a new element is inserted in vector then it internally shifts its elements and hence the old iterators become invalidated.
    // Reasons for element shift are as follows,
    //    If element is inserted in between then it shift all the right elements by 1.
    //    If the new size of vector is more than its current capacity, 
    //    then it relocates a bigger chunk of memory and copies all the elements there.
    void test2()
    {

        std::vector<int> vecArr;
        for (int i = 1; i <= 10; i++)
            vecArr.push_back(i);

        auto it = vecArr.begin();
        for (; it != vecArr.end(); it++)
            std::cout << (*it) << "  ";

        std::cout << std::endl;

        it = vecArr.begin();

        // Insert an element in position 2,
        vecArr.insert(it + 2, 1, 200);

        // Now old iterator it has become invalidated
        // SO, using it as it is can result in undefined behavior

        for (; it != vecArr.end(); it++)   // Undefined Behavior
            std::cout << (*it) << "  ";          // Undefined Behavior

        return;
    }
    //Solution:
    // After calling the insert function update the value of iterator ¡®it¡¯ i.e.by re - assigning it.
    //    // Insert an element in position 2,
    //    vecArr.insert(it + 2, 1, 200);

    //// Reinitialize the invalidated iterator to the begining.
    //   it = vecArr.begin();
}

namespace removeAllOccurencesOfAnElementFromVector {
    /*
    Suppose we have a vector of integers and we want to delete all occurences of a number from it i.e.

    Let¡¯s say vector contain following numbers 1,2,5,4,5,1,5,7,8,9.
    Now we want to delete all the occurences of 5 from it, so that vector contents should become ¨C 1 2 4 1 7 8 9 .
    Also the order of elements should be mentained.
    */
    
    // First Method: A Non efficient way
    // 1.) Iterate through all elements in vector and check for each elements if it matches with required number.
    // 2.) If it matches then erase that element and go forward.
    /*
        std::vector<int>::iterator it = vec.begin();
        while(it != vec.end())
        {
            if(*it == elem)
            {
                it = vec.erase(it);
            }
            else
                it++;
        }
    */

    // Second Method : An Efficient Way
}

namespace beCarefulWithHiddenCostForUserDefinedObjects {
    // While creating and using std::vector with user defined classes '
    // we needs some special care otherwise it can hamper the performance of our application.

    //Suppose we have an Item Class,
    class Item {
    public:
        static int m_ConstructorCalledCount;
        static int m_DestCalledCount;
        static int m_CopyConstructorCalledCount;
        Item() {
            m_ConstructorCalledCount++;
        }
        ~Item() {
            m_DestCalledCount++;
        }
        Item(const Item& obj) {
            m_CopyConstructorCalledCount++;
        }
    };
    int Item::m_ConstructorCalledCount = 0;
    int Item::m_CopyConstructorCalledCount = 0;
    int Item::m_DestCalledCount = 0;

    //And we want to create a vector of 10000 Item objects.
    //    So, let¡¯s create a factory class for it,
    class ItemFactory
    {
    public:
        static std::vector<Item> getItemObjects(int count)
        {
            std::vector<Item> vecOfItems;
            vecOfItems.reserve(count);
            for (int var = 0; var < count; ++var) {
                vecOfItems.push_back(Item());
            }
            return vecOfItems;
        }
    };

    // Now let¡¯s use this factory to create objects,
    void test()
    {
        int count = 10000;
        std::vector<Item> vecOfItems;
        vecOfItems = ItemFactory::getItemObjects(count);

        std::cout << "Total Item Objects constructed = " << (Item::m_ConstructorCalledCount + Item::m_CopyConstructorCalledCount) << std::endl;
        std::cout << "Constructor called  " << Item::m_ConstructorCalledCount << " times" << std::endl;
        std::cout << "Copy Constructor called  " << Item::m_CopyConstructorCalledCount << " times" << std::endl;
        std::cout << "Total Item Objects destructed = " << Item::m_DestCalledCount << std::endl << std::endl;
    }
    // Above code seems fine, we created 10000 objects of class Item. 
    // But while creating these 10000 object we wasted  20000 objects, that¡¯s double of what we actually needed.

    //Now with a small change we can reduce the wasted object count to 10000 from 20000 i.e.
    void test2()
    {
        int count = 10000;
        std::vector<Item> vecOfItems = ItemFactory::getItemObjects(count);
        std::cout << "Total Item Objects constructed = " << (Item::m_ConstructorCalledCount + Item::m_CopyConstructorCalledCount) << std::endl;
        std::cout << "Constructor called  " << Item::m_ConstructorCalledCount << " times" << std::endl;
        std::cout << "Copy Constructor called  " << Item::m_CopyConstructorCalledCount << " times" << std::endl;
        std::cout << "Total Item Objects destructed = " << Item::m_DestCalledCount << std::endl << std::endl;
    }

    //We can do this by 2 ways,
    //    1.) Instead of returning the whole new vector from factory function, just passing the new vector as a reference to factory function i.e.
    static void getItemObjects_1(std::vector<Item> & vecItems, int count)
    {
        vecItems.assign(count, Item());
    }
    void test3()
    {
        int count = 10000;
        std::vector<Item> vecOfItems;
        getItemObjects_1(vecOfItems, count);
        std::cout << "Total Item Objects constructed = " << (Item::m_ConstructorCalledCount + Item::m_CopyConstructorCalledCount) << std::endl;
        std::cout << "Constructor called  " << Item::m_ConstructorCalledCount << " times" << std::endl;
        std::cout << "Copy Constructor called  " << Item::m_CopyConstructorCalledCount << " times" << std::endl;
        std::cout << "Total Item Objects destructed = " << Item::m_DestCalledCount << std::endl << std::endl;
    }
}

int main()
{
    //howToFillVectorWithRandomNumbers::test();
    //howToFillVectorWithRandomNumbers::test2();

    //inportanceOfContructorsWhileUsingUserDefinedObjects::test();

    //beCarefulWithHiddenCostForUserDefinedObjects::test();
    //beCarefulWithHiddenCostForUserDefinedObjects::test2();
    beCarefulWithHiddenCostForUserDefinedObjects::test3();

    return 0;
}